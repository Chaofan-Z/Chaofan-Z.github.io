{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Start","text":"这里记录下自己学习的知识和心得，主要是记录leetcode刷题时的经验，以及其他自己有用没用看到的，学到的知识。 总之，希望这里是一个我output的地方，也算是一种学习上的自我监督。 希望2021年秋招能够拿到理想的offer，或者能够明确未来5到10年的奋斗和发展方向。","link":"/2020/08/31/start/"},{"title":"动态规划专题","text":"背包问题分析记得刚刚接触到dp的时候，还是大一参加学院ACM小组例会时。当时学长讲到背包问题时候，觉得很神奇，为什么这样迭代就可以保证的是最优解，记得回去路上还跟小伙伴进行了很热情的讨论，可惜当时没有坚持下来（甚至没开始坚持）。今天重新回忆下，自己做点总结，理一下思路！ 1. 01背包问题1.1 题目有N件物品，第$i$件物品的价值是$V_i$，还有一个容量为$V$的背包，问题：怎么装才能尽可能的使得背包里面的物品价值更多？ 1.2 思路首先要明确每个物品仅有一个，不能多次利用。最直观的方法，可以暴力搜索尝试每一种组合，还有就是当时记得看到这种第一反应是贪心可不可以，按照单位价值排序物品，依次放入可不可行。当然贪心是不可以的这里举个例子，物品重量[3, 4, 6, 7]，物品价值为[3, 7, 11, 14]，背包容积10，按照贪心思想会选择重量为3和7的物品，总价值为17，但是实际重量为4和6的物品，其价值为18。 动态规划：用子问题定义状态，dp[i, v]表示前i件物品，v容量，装出的最大价值。转移方程，对第i件物品，空间v的状态来讲，有两种选择，装入第i件物品，不装第i件物品，则有以下方程：$$dp[i, v] = max(dp[i-1, v], dp[i-1, v-cost[i]] + value[i])$$ 1.3 伪代码对于dp，我觉得写代码之前要搞清几个事情 列出子问题状态的表达以及对应意义 动态转移方程 状态初始化值，初始化值和遍历顺序综合考虑，不要出现无法迭代，越界，非法值等问题 遍历顺序，以及特殊限定 1234567// 初始化 dp[N+1][V+1] ，dp[0, 0-&gt;V] = 0, // 从1开始，方式i-1越界，设计value和cost时候i-1for(int i=1; i&lt;=N; i++){ for(int v=cost[i - 1]; v&lt;=V; v++){ dp[i][v] = max(dp[i-1][v], dp[i-1][v-cost[i - 1]] + value[i - 1]) }} 复杂度分析：上述代码，空间复杂度O(VN)，时间复杂度O(VN)，按照目前这个情况，似乎时间复杂度没法优化了，但是空间上还可以做点事情。1234567// 初始化 dp[V+1], dp[0-&gt;V] = 0// 第二层遍历时候，倒序遍历，看转移方程中dp[v - cost[i]]相当于dp[i-1][v-cost[i]]，也就是针对物品i-1更新出来的值，因此只有倒序遍历才能访问到在这个位置上次更新的值如果正序遍历，会在dp[v - cost[i]]覆盖掉dp[i-1][v-cost[i]]变为dp[i][v-cost[i]]for(int i=0; i&lt;N; i++){ for(int v=C; v &gt;= cost[i]; v--){ dp[v] = max(dp[v], dp[v - cost[i]] + value[i]) }} 1.4 值得注意的几个点刚刚列出了自己认为比较重要的四个点，这里对初始化详细讨论下。首先有几个常见的限定条件： 恰好装满背包，初始化dp[0] = 0，其余都负无穷，这样方程转移是必须让容积全部使用后才可以更新，其他的无法通过max更新 物品数量无限（完全背包），二层循环时候，倒序变正序即可，这样更新的是当前物品更新过的之前的状态 2. 完全背包区别在于，物品数量不限制。 2.1 思路首先对数据筛选，如果物品i重量比物品j低，价值却比其高，那么可以果断舍弃物品j。 其次思考问题，每种物品最多可能只能装k件，那么可以将一个物品拆分为k种物品，强行转换为01背包解决，在此基础上，不用转换为k种物品这么多，用二进制，比如能装7个物品，那么可以转换为4，2，1三种，这样7以下的所有组合都可以考虑到，即便如此整体还是比较繁琐的。 所以，参考1.4，完全背包问题，时间复杂度和01背包可以保持一致都是O(VN) 123456// 初始化, dp[0 -&gt; V] = 0 for(int i=0; i&lt;N; i++){ for(int v=cost[i]; v&lt;=V; v++){ dp[v] = max(dp[v], dp[v-cost[i]] + value[i]) }} 3. 小结其实背包仍然有很多相关问题，比如多重背包问题等。但是就目前看到的题目来说，最近本dp的思想其实是比较重要的，剩下的解题方法和技巧，就在实战中不断磨练吧！ todo : 两个循环调换一下是什么样呢，循环的顺序（是否01or完全） 实际题目Leetcode474 一和零类似01背包问题，但是其不同之处在于，物品的重量被分割为了两个维度，其余基本是一致的。下面伪代码，设定物品两个维度的限制分别为x和y，物品的价值都是1 12345678910// 实际前面隐藏了个k维度，也就是01背包当中第一个物品的那个维度，这里为了简化空间复杂度，可以看到后面两个遍历是倒序，也是为了访问k-1状态的值// 注意下面方程中的k-1// dp[k][i][j] = max(dp[k-1][i][j], dp[k-1][i-x[k]][j-y[k]])for(int k=0; k&lt;size; k++){ for(int i=m; i&gt;=0; i--){ for(int j=n; j&gt;=0; j--){ dp[i][j] = max(dp[i][j], dp[i-x[k]][j-y[k]]) } }}","link":"/2020/09/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"}]}